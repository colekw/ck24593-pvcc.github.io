<!DOCTYPE html>
<html lang="en">

<head>
	<title>Chapter 7: Software Engineering</title>
</head>

<body>
	<section class="wrapper-main">
		<table>
			<tr>
				<th>Term</th>
				<th>Definition</th>
			</tr>
			<tr>
				<td>Phases of Computer Program Development</td>
				<td>
					<ol>
						<li>Understand the problem</li>
						<li>Design an algorithm to solve the problem</li>
						<li>Write the program code in an appropriate language based on the algorithm</li>
						<li>Enter the program and save</li>
						<li>Execute the program</li>
						<li>Test the program, find errors and debug, then retest</li>
						<li>Document and evaluate the program</li>
					</ol>
				</td>
			</tr>
			<tr>
				<td>Sequential Structure</td>
				<td>Top-down execution</td>
			</tr>
			<tr>
				<td>Decision Structures</td>
				<td>if/then/else</td>
			</tr>
			<tr>
				<td>While Loop</td>
				<td>Continue looping as long as something is true</td>
			</tr>
			<tr>
				<td>Repeat/Until Loop</td>
				<td>Continue looping until something is true</td>
			</tr>
			<tr>
				<td>For Loop</td>
				<td>Loop a given number of times</td>
			</tr>
			<tr>
				<td>Recursive Structures</td>
				<td>
					<p>Repeat a set of instructions as a subtask of itself.</p>
					<p>Repetition continues until a degenerative case (termination condition) is met. The degenerative case is also called a "base case."</p>
				</td>
			</tr>
			<tr>
				<td>Two Classic Programming/Database Problems</td>
				<td>
					<ol>
						<li>Sorting:
							<ul>
								<li>Descending order</li>
								<li>Ascending order</li>
								<li>Sorting strings (in accordance with ASCII values)</li>
							</ul>
						</li>
						<li>Searching:
							<ul>
								<li>Find specific data that meets a certain criteria</li>
								<li>Filters: Temporary search</li>
								<li>Queries: Search criteria are saved so they don't have to be recreated</li>
								<li>Sequential search: Search from top to bottom or bottom to top, one item at a time</li>
								<li>Binary search: Only works if data is sorted first, start in the middle, then go to half of that, etc.</li>
							</ul>
						</li>
					</ol>
				</td>
			</tr>
			<tr>
				<td>Efficiency</td>
				<td>Program takes minimal time and/or resources</td>
			</tr>
			<tr>
				<td>Correctness</td>
				<td>Program runs in expected ways and works for all expected conditions</td>
			</tr>
		</table>
	</section>
	<head>
		<title>Software Testing and Verification</title>
	</head>
	<body>
		<section class="wrapper-main">
			<table>
				<tr>
					<th>Term</th>
					<th>Definition</th>
				</tr>
				<tr>
					<td>Acceptance Testing</td>
					<td>Verifying whether the whole system works as intended.</td>
				</tr>
				<tr>
					<td>Integration Testing</td>
					<td>Ensuring that software components or functions operate together.</td>
				</tr>
				<tr>
					<td>Unit Testing</td>
					<td>Validating that each software unit performs as expected. A unit is the smallest testable component of an application.</td>
				</tr>
				<tr>
					<td>Functional Testing</td>
					<td>Checking functions by emulating business scenarios, based on functional requirements. Black-box testing is a common way to verify functions.</td>
				</tr>
				<tr>
					<td>Performance Testing</td>
					<td>Testing how the software performs under different workloads. Load testing, for example, is used to evaluate performance under real-life load conditions.</td>
				</tr>
				<tr>
					<td>Regression Testing</td>
					<td>Checking whether new features break or degrade functionality. Sanity testing can be used to verify menus, functions, and commands at the surface level when there is no time for a full regression test.</td>
				</tr>
				<tr>
					<td>Stress Testing</td>
					<td>Testing how much strain the system can take before it fails. Considered to be a type of non-functional testing.</td>
				</tr>
				<tr>
					<td>Usability Testing</td>
					<td>Validating how well a customer can use a system or web application to complete a task.</td>
				</tr>
				<tr>
					<td>Software Testing</td>
					<td>Done to detect architectural flaws, poor design decisions, invalid or incorrect functionality, security vulnerabilities, and scalability issues.</td>
				</tr>
				<tr>
					<td>Continuous Testing</td>
					<td>Teams test builds as soon as it becomes available. It enables software to be validated in a real-time environment.</td>
				</tr>
				<tr>
					<td>Configuration Management</td>
					<td>The systematic process of managing and controlling changes to a system's components, ensuring that the system remains consistent and reliable.</td>
				</tr>
				<tr>
					<td>Service Virtualization</td>
					<td>If testing is not yet available, it can simulate the system, allowing devs to test and simulate functionality.</td>
				</tr>
				<tr>
					<td>Defect or "Bug Tracking"</td>
					<td>Monitoring defects is important to both testing and development teams for measuring and improving quality. Tools allow teams to measure and improve quality.</td>
				</tr>
				<tr>
					<td>Metrics and Reporting</td>
					<td>Allows group members to share information, defects, measure progress, and uncover more issues. From: <a href="https://www.ibm.com/topics/software-testing">IBM What is Software Testing</a>.</td>
				</tr>
			</table>
		</section>
	</body>

</html>
